# Advanced infer Patterns

ğŸ‘¨â€ğŸ’¼ Now that you understand basic `infer`, let's use it for more complex
patterns including function parameters and tuple manipulation.

```ts
type SignalHandler = (signal: { type: 'tick' }, count: number) => string
type HandlerResult<T> = T extends (...args: Array<any>) => infer R ? R : never

type Result = HandlerResult<SignalHandler> // string
```

## Function Patterns

```ts
// Extract return type
type ReturnType<T> = T extends (...args: Array<any>) => infer R ? R : never

// Extract all parameters as a tuple
type Parameters<T> = T extends (...args: infer P) => any ? P : never

// Extract first parameter
type FirstArg<T> = T extends (first: infer F, ...rest: Array<any>) => any
	? F
	: never
```

## Rest Patterns in Tuples

You can use `infer` with rest patterns (`...`) to extract parts of tuples:

```ts
// Get the last element of a tuple
type Last<T extends Array<any>> = T extends [...infer _, infer L] ? L : never

// The [...infer _] captures "everything except the last" into _
// The [infer L] captures the last element into L

type Example = Last<[1, 2, 3]> // 3
type Example2 = Last<['a', 'b']> // 'b'
```

ğŸ¨ Open <InlineFile file="index.ts" /> and:

1. Recreate `MyReturnType<T>` from scratch
2. Recreate `MyParameters<T>` from scratch
3. Create `PromiseValue<T>` to unwrap Promises
4. Create `FirstArg<T>` to get a function's first argument type
5. Create `LastArg<T>` using rest tuple patterns

ğŸ“œ [TypeScript Handbook - Inferring Within Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)
